#+TITLE: Notes

Notes aiming to provide reflection and insight on the process, so I can improve
my methodology.

* Times/day summaries

#+BEGIN: clocktable :scope file :maxlevel 2
#+CAPTION: Clock summary at [2021-12-08 Wed 21:41]
| Headline                | Time   |      |
|-------------------------+--------+------|
| *Total time*            | *8:03* |      |
|-------------------------+--------+------|
| Tracking and Reflection | 8:03   |      |
| \_  Day 5               |        | 1:53 |
| \_  Day 6               |        | 1:09 |
| \_  Day 7               |        | 2:31 |
| \_  Day 8               |        | 2:30 |
#+END:


* Process

An evolving checklist of "best practices" emerging as I work through the
problems.

1. Add [[* Template][new entry]] for notes for the day and clock in
2. Set up test harness in  [[./test]]
   - Copy test input into =./test/dayN.t/test=
   - Copy puzzle input into =./test/dayN.t/input=
   - Set up integration tests in =./test/dayN.t/run.t=
3. Set up solution scaffolding:
   - Add module =DayN.ml= to [[./bin]]
   - Add skeleton to module:
       #+begin_src ocaml
       open Containers

       module type Domain = sig
         (* TODO Specification of domain *)
       end

       module Solver (D : Domain) = struct
         let solve : string Array.t -> string Seq.t -> int =
           fun params lines ->
           (* TODO Solution to puzzle *)
             (??)
       end

       module D : Domain = struct
         (* TODO Implementation of domain *)
       end

       (* Instantiate the solver *)
       include Solver (D)
       #+end_src
     - Register the module in the [[./bin/main.ml::5][solvers]]
4. Extract semi-formal specification from puzzle description (as bullet points)
5. Write implementation plan as bullet points
6. Specify the =Domain= interface
7. Implement preliminary =Solver= algorithm (usually calling for adjustments to =Domain=)
8. Implement =Domain= in =D=

* Tracking and Reflection
** Days 1 to 5

Was not taking notes or recording times.

Main takeaways:

- Avoid refactoring foo: some refactoring to reuse parts can be help accelerate,
  but it's also an easy place to procrastinate and avoid actually tackling the
  problems.
- Specify problems at type level *before* implementing. Helps prevent losing
  focus, since you can focus just on the high level representation, then get the
  type checker to give an interactive "checklist" of values you need to
  implement.
- If the aim is time-efficient implementations, don't rely on OCaml's till
  impoverished stdlib. I ended up having to implement too many basic utility
  functions. From Day 5 on, I'm helping myself to [[https://github.com/c-cube/ocaml-containers][Containers]].
- Bullet-point out the key details of the specification before starting to code
  up anything. Most of the mistakes that have slowed me down have come from
  making minor mistakes at the value-level during specification.


** DONE Day 5
:LOGBOOK:
CLOCK: [2021-12-05 Sun 12:00]--[2021-12-05 Sun 12:13] =>  0:13
CLOCK: [2021-12-05 Sun 09:28]--[2021-12-05 Sun 09:49] =>  0:21
CLOCK: [2021-12-05 Sun 08:04]--[2021-12-05 Sun 09:23] =>  1:19
:END:

*** Implementation

[[./bin/day5.ml][Solution]]

**** Errors
- Was initializing map locations incorrectly initially, setting them to 0 at the
  first marked point, rather to 1.
- Misread the specification: it called for returning the *number of points with
  2 or more overlapping vents*, but I was returning *the sum of all spaces with
  2 or more overlapping vents*.

Both of these errors are results of not carefully attending to *specific value
ranges* detailed by the specification.
**** To improve

- Bullet-point specification in english before writing formalizing specification
  in types.

** DONE Day 6
:LOGBOOK:
CLOCK: [2021-12-06 Mon 02:26]--[2021-12-06 Mon 03:35] =>  1:09
:END:

*** Specification

- Given :: A list of numbers representing ages of lanternfish
- Produce :: The number of fish expected at 80 days
- Domain ::
  - Each mature lanternfish creates a new fish after 7 days
  - Newly born lanternfish take +2 days to mature

- Representation ::
  - Represent each lantern fish as a single number, which acts as a counter
  - Represent a day passing as an iteration that reduces all counters
  - 1 new counter is created when any counter decreases from 0
  - A new counter start at 8 (2 days to mature + 7 days to produce)
  - After a counter reaches 0, it resets to 6

*** Implementation
[[./bin/day6.ml][Solution]]

- We only have 9 counter states to track: 0 to 8.
- To compute the number of new counters spawned, we need only track how many of
  each counter are in each state.
- So we can represent the state space as an =int Array.t= of length 9, where the
  =j_th= int represents the number of counters in that state.
- Proof that this alternative representation is equivalent to the one
  specified is given by the pair of functions

    - =array_to_counters : int Array.t -> int list=
    - =counters_to_array : int list -> int Array.t=

  defining an isomorphic mapping between the compressed representation and the
  list of counters.

*** Reflection

Today went very smoothly. Whether it was because today's puzzle was easier, or
admitted an elegant solution more easily than previous days, whether I just got
lucky striking on the right representation, or whether my process improvements
may be helping, I feel that it was pretty nearly ideal.

I also used an imperative solution today. I wonder if this could have
contributed to the cleaner process in this (particular) case?

**** Errors
Two small errors in counter increment logic.

- I placed the updates adding the new counters and the reset counters in the
  same loop used to shift the counters to the left.
- I had an off by one error, setting the expired counters to index 5 instead of
  6.

**** To improve
- Write implementation plan in bullet points first.
- *Keep the domain abstract*. This gives much more flexibility in improving the
  representation, which you'll likely want to do, since working the problem will
  bring more insight into the structures you can draw upon.
- [[https://www.youtube.com/playlist?list=PLqgbyDNJ3NvVBYzC5CJ_9sjcnx2pueo4h]["first thought, best thought"]] is usually not the case, so give the initial
  representation and strategy a second thought.
- Writing out algorithm in bullet points prior to coding may have helped
  avoid the two errors I encountered.
** DONE Day 7
:LOGBOOK:
CLOCK: [2021-12-07 Tue 22:00]--[2021-12-07 Tue 22:48] =>  0:48
CLOCK: [2021-12-07 Tue 21:01]--[2021-12-07 Tue 21:32] =>  0:31
CLOCK: [2021-12-07 Tue 20:38]--[2021-12-07 Tue 20:39] =>  0:01
CLOCK: [2021-12-07 Tue 19:45]--[2021-12-07 Tue 20:35] =>  0:50
CLOCK: [2021-12-07 Tue 07:56]--[2021-12-07 Tue 08:17] =>  0:21
:END:
*** Specification
- input: horizontal positions of crab submarines
- aim: get all horizontal positions to match while minimizing fuel expenditure
- output: integer representing the least amount of fuel needed to make all
  horizontal positions equal

- crab submarines
- each crab has a horizontal position
- each crab has limited fuel
- moving horizontal position by 1 unit costs 1 unit of fuel

*** Implementation

- Some preliminary research indicates that a truly elegant structure might be
  found by looking at [[https://en.wikipedia.org/wiki/Graph_bandwidth][graph bandwidth]] problems. But I think the overhead for me
  getting conversant with the prerequisites to encode that effectively will be
  too costly.

- Similar to the compression for day 6, we can group each "crab" by sets of
  values. So we can use a hashmap of =int -> int=, where the key is the
  position of the crab and the value is the number of grabs at that position.
  Then we can calculate the fuel cost to =x= for all crabs as =|x - position| *
  num_crabs=.
- To find the alignment position requiring minimum adjustment, we can do a
  binary search starting with the min and max positions in the set.
  - There is probably an optimization to be found here by taking into account
    how many crabs are at each position, but I won't bother with this unless I
    hit a bottlneck.

Plan:

- Parse in crab positions
- Get min and max positions
- Create hashmap: =position -> num_crabs=
- Get mean of positions
- Find cost of mean position
- Get cost of mean +/- 1
  - If +1 is lower than mean, then search ascending
  - If -1 is lower than mean, then search descending
- Stop search when next post is more costly than prev

[[./bin/day7.ml][Solution]]
*** Reflection

I wasn't able to block out contiguous time to focus to today, so that made
things a bit slower and more muddled.

I also didn't hit a really elegant solution comparable to yesterday. I think
such a solution would have been available if I knew more math facts, but I just
didn't have the mechanisms at hand. Part 2 still completes in 0.004 seconds, so
it's relatively performant, but it's the code itself feels a bit ad hoc.

Still, my process overall is working pretty well.

**** Errors
- Confused the placement of arguments in initial search for min value
- Forgot to handle zero case in my triangle number function
**** To improve
...

** STRT Day 8
:LOGBOOK:
CLOCK: [2021-12-08 Wed 20:56]--[2021-12-08 Wed 21:33] =>  0:37
CLOCK: [2021-12-08 Wed 19:26]--[2021-12-08 Wed 20:21] =>  0:55
CLOCK: [2021-12-08 Wed 19:20]--[2021-12-08 Wed 19:23] =>  0:03
CLOCK: [2021-12-08 Wed 17:37]--[2021-12-08 Wed 17:54] =>  0:17
CLOCK: [2021-12-08 Wed 08:11]--[2021-12-08 Wed 08:13] =>  0:02
CLOCK: [2021-12-08 Wed 07:35]--[2021-12-08 Wed 08:11] =>  0:36
:END:
*** Specification

- Input: Lines of entries correlating signal patterns to output values

- Signal patterns and output values in an entry are separated by `|`
- Each entry has 10 unique signal patterns, representing how the 10 digits of a
  clock are signaled.
- Each entry has a four digit output value
- ...

**** Part 1:
- Output: Count of the number of times 1, 4, 7, or 8 appear in output values

- These 4 digits have a unique number of segments:
  - 1 :: 2
  - 4 :: 4
  - 7 :: 3
  - 8 :: 7
- So we can identify them in the outputs simply by counting encoded digits that
  have the respective number of segments.

**** Part 2:

- Output: The sum of all output values

- Using the uniquely identifiable digits as reference, we can decode the
  segments triggered by each signal.
- Use the decoding algorithm to decode all outputs
- Then return their sum

*** Implementation
[[./bin/day8.ml][Solution]]

**** Part 1

- Parse each line into representation that groups the signal patterns and the
  output values (for now, we can just work on a sequence of such representation,
  because we only need to traverse once.)
- Fold over the seq, counting the number of "digits" (strings) in the output
  values that have segments in the specified unique values.

**** Part 2

- Each digit is uniquely represented as a set of characters (which represent
  the signals)
- Determine the encoding of the signal on each entry using the following chart:

  | Digit | Segments | Id By                   |
  |-------+----------+-------------------------|
  |     1 | #2       | uniq #2                 |
  |     7 | #3       | uniq #3                 |
  |     4 | #4       | uniq #4                 |
  |     2 | #5       | remaining #5            |
  |     5 | #5       | intersection of 9 and 6 |
  |     3 | #5       | #5 where 1 is subset    |
  |     0 | #6       | #6 where 7 is subset    |
  |     6 | #6       | remaining #6            |
  |     9 | #6       | #6 where 4 is subset    |
  |     8 | #7       | uniq #7                 |

- Represent the encoding as a map from sets to ints
- Lookup the digital value of each char set in the outputs
- Construct the int based on the digits
- Fold over of the decoded ints to sum them

*** Reflection

- Completed part 1 in ~30 mins with no errors. But it was very simple.
- Part 2 took me an additional 2 hours. Some complication from unrelated
  emotional distress, and some from having to fight some unhelpful negative
  thought patterns.
    - Namely, when some problems take a lot of time, or I get confused while
      working through something, I have a tendency to start judging,
      belittling, and being impatient with myself. Thinking such toxic thoughts
      as: you are too stupid to do this kind of work, you are too slow, you
      can't think clearly, why don't you have enough energy/stamina etc.
    - It took me some moments to catch this bad pattern taking shape, and to
      remind myself that to be patient and kind to myself. These kinds of things
      can be hard. And, in any case, I am only trying to learn, to improve, and
      to have fun!

**** Errors
No errors! I'm quite surprised, but my solutions to both parts worked correctly
on the test input first try, and no errors were made when translating my
specs and plans into implementation.
**** To improve
I neglected to exercise today or yesterday (aside from a short walk). I suspect
this is taking a toll. So, I must make time for this tomorrow.

* Template
** Day N
*** Specification
*** Implementation
[[./bin/dayN.ml][Solution]]
*** Reflection
**** Errors
**** To improve
