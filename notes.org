#+TITLE: Notes

Notes aiming to provide reflection and insight on the process, so I can improve
my methodology.

* Times/day summaries

#+BEGIN: clocktable :scope file :maxlevel 2
#+CAPTION: Clock summary at [2021-12-07 Tue 22:48]
| Headline                | Time   |      |
|-------------------------+--------+------|
| *Total time*            | *5:33* |      |
|-------------------------+--------+------|
| Tracking and Reflection | 5:33   |      |
| \_  Day 5               |        | 1:53 |
| \_  Day 6               |        | 1:09 |
| \_  Day 7               |        | 2:31 |
#+END:


* Process

An evolving checklist of "best practices" emerging as I work through the
problems.

1. Add [[* Template][new entry]] for notes for the day and clock in
2. Set up test harness in  [[./test]]
   - Copy test input into =./test/dayN.t/test=
   - Copy puzzle input into =./test/dayN.t/input=
   - Set up integration tests in =./test/dayN.t/run.t=
3. Set up solution scaffolding:
   - Add module =DayN.ml= to [[./bin]]
   - Add skeleton to module:
       #+begin_src ocaml
       open Containers

       module type Domain = sig
         (* TODO Specification of domain *)
       end

       module Solver (D : Domain) = struct
         let solve : string Array.t -> string Seq.t -> int =
           fun params lines ->
           (* TODO Solution to puzzle *)
             (??)
       end

       module D : Domain = struct
         (* TODO Implementation of domain *)
       end

       (* Instantiate the solver *)
       include Solver (D)
       #+end_src
     - Register the module in the [[./bin/main.ml::5][solvers]]
4. Extract semi-formal specification from puzzle description (as bullet points)
5. Write implementation plan as bullet points
6. Specify the =Domain= interface
7. Implement preliminary =Solver= algorithm (usually calling for adjustments to =Domain=)
8. Implement =Domain= in =D=

* Tracking and Reflection
** Days 1 to 5

Was not taking notes or recording times.

Main takeaways:

- Avoid refactoring foo: some refactoring to reuse parts can be help accelerate,
  but it's also an easy place to procrastinate and avoid actually tackling the
  problems.
- Specify problems at type level *before* implementing. Helps prevent losing
  focus, since you can focus just on the high level representation, then get the
  type checker to give an interactive "checklist" of values you need to
  implement.
- If the aim is time-efficient implementations, don't rely on OCaml's till
  impoverished stdlib. I ended up having to implement too many basic utility
  functions. From Day 5 on, I'm helping myself to [[https://github.com/c-cube/ocaml-containers][Containers]].
- Bullet-point out the key details of the specification before starting to code
  up anything. Most of the mistakes that have slowed me down have come from
  making minor mistakes at the value-level during specification.


** DONE Day 5
:LOGBOOK:
CLOCK: [2021-12-05 Sun 12:00]--[2021-12-05 Sun 12:13] =>  0:13
CLOCK: [2021-12-05 Sun 09:28]--[2021-12-05 Sun 09:49] =>  0:21
CLOCK: [2021-12-05 Sun 08:04]--[2021-12-05 Sun 09:23] =>  1:19
:END:

*** Implementation

[[./bin/day5.ml][Solution]]

**** Errors
- Was initializing map locations incorrectly initially, setting them to 0 at the
  first marked point, rather to 1.
- Misread the specification: it called for returning the *number of points with
  2 or more overlapping vents*, but I was returning *the sum of all spaces with
  2 or more overlapping vents*.

Both of these errors are results of not carefully attending to *specific value
ranges* detailed by the specification.
**** To improve

- Bullet-point specification in english before writing formalizing specification
  in types.

** DONE Day 6
:LOGBOOK:
CLOCK: [2021-12-06 Mon 02:26]--[2021-12-06 Mon 03:35] =>  1:09
:END:

*** Specification

- Given :: A list of numbers representing ages of lanternfish
- Produce :: The number of fish expected at 80 days
- Domain ::
  - Each mature lanternfish creates a new fish after 7 days
  - Newly born lanternfish take +2 days to mature

- Representation ::
  - Represent each lantern fish as a single number, which acts as a counter
  - Represent a day passing as an iteration that reduces all counters
  - 1 new counter is created when any counter decreases from 0
  - A new counter start at 8 (2 days to mature + 7 days to produce)
  - After a counter reaches 0, it resets to 6

*** Implementation
[[./bin/day6.ml][Solution]]

- We only have 9 counter states to track: 0 to 8.
- To compute the number of new counters spawned, we need only track how many of
  each counter are in each state.
- So we can represent the state space as an =int Array.t= of length 9, where the
  =j_th= int represents the number of counters in that state.
- Proof that this alternative representation is equivalent to the one
  specified is given by the pair of functions

    - =array_to_counters : int Array.t -> int list=
    - =counters_to_array : int list -> int Array.t=

  defining an isomorphic mapping between the compressed representation and the
  list of counters.

*** Reflection

Today went very smoothly. Whether it was because today's puzzle was easier, or
admitted an elegant solution more easily than previous days, whether I just got
lucky striking on the right representation, or whether my process improvements
may be helping, I feel that it was pretty nearly ideal.

I also used an imperative solution today. I wonder if this could have
contributed to the cleaner process in this (particular) case?

**** Errors
Two small errors in counter increment logic.

- I placed the updates adding the new counters and the reset counters in the
  same loop used to shift the counters to the left.
- I had an off by one error, setting the expired counters to index 5 instead of
  6.

**** To improve
- Write implementation plan in bullet points first.
- *Keep the domain abstract*. This gives much more flexibility in improving the
  representation, which you'll likely want to do, since working the problem will
  bring more insight into the structures you can draw upon.
- [[https://www.youtube.com/playlist?list=PLqgbyDNJ3NvVBYzC5CJ_9sjcnx2pueo4h]["first thought, best thought"]] is usually not the case, so give the initial
  representation and strategy a second thought.
- Writing out algorithm in bullet points prior to coding may have helped
  avoid the two errors I encountered.
** STRT Day 7
:LOGBOOK:
CLOCK: [2021-12-07 Tue 22:00]--[2021-12-07 Tue 22:48] =>  0:48
CLOCK: [2021-12-07 Tue 21:01]--[2021-12-07 Tue 21:32] =>  0:31
CLOCK: [2021-12-07 Tue 20:38]--[2021-12-07 Tue 20:39] =>  0:01
CLOCK: [2021-12-07 Tue 19:45]--[2021-12-07 Tue 20:35] =>  0:50
CLOCK: [2021-12-07 Tue 07:56]--[2021-12-07 Tue 08:17] =>  0:21
:END:
*** Specification
- input: horizontal positions of crab submarines
- aim: get all horizontal positions to match while minimizing fuel expenditure
- output: integer representing the least amount of fuel needed to make all
  horizontal positions equal

- crab submarines
- each crab has a horizontal position
- each crab has limited fuel
- moving horizontal position by 1 unit costs 1 unit of fuel

*** Implementation

- Some preliminary research indicates that a truly elegant structure might be
  found by looking at [[https://en.wikipedia.org/wiki/Graph_bandwidth][graph bandwidth]] problems. But I think the overhead for me
  getting conversant with the prerequisites to encode that effectively will be
  too costly.

- Similar to the compression for day 6, we can group each "crab" by sets of
  values. So we can use a hashmap of =int -> int=, where the key is the
  position of the crab and the value is the number of grabs at that position.
  Then we can calculate the fuel cost to =x= for all crabs as =|x - position| *
  num_crabs=.
- To find the alignment position requiring minimum adjustment, we can do a
  binary search starting with the min and max positions in the set.
  - There is probably an optimization to be found here by taking into account
    how many crabs are at each position, but I won't bother with this unless I
    hit a bottlneck.

Plan:

- Parse in crab positions
- Get min and max positions
- Create hashmap: =position -> num_crabs=
- Get mean of positions
- Find cost of mean position
- Get cost of mean +/- 1
  - If +1 is lower than mean, then search ascending
  - If -1 is lower than mean, then search descending
- Stop search when next post is more costly than prev

[[./bin/day7.ml][Solution]]
*** Reflection

I wasn't able to block out contiguous time to focus to today, so that made
things a bit slower and more muddled.

I also didn't hit a really elegant solution comparable to yesterday. I think
such a solution would have been available if I knew more math facts, but I just
didn't have the mechanisms at hand. Part 2 still completes in 0.004 seconds, so
it's relatively performant, but it's the code itself feels a bit ad hoc.

Still, my process overall is working pretty well.

**** Errors
- Confused the placement of arguments in initial search for min value
- Forgot to handle zero case in my triangle number function
**** To improve

...


* Template
** Day N
*** Specification
*** Implementation
[[./bin/dayN.ml][Solution]]
*** Reflection
**** Errors
**** To improve
