#+TITLE: Notes

Notes aiming to provide reflection and insight on the process, so I can improve
my methodology.

* Times/day summaries

#+BEGIN: clocktable :scope file :maxlevel 2
#+CAPTION: Clock summary at [2021-12-06 Mon 03:44]
| Headline                | Time   |      |
|-------------------------+--------+------|
| *Total time*            | *3:02* |      |
|-------------------------+--------+------|
| Tracking and Reflection | 3:02   |      |
| \_  Day 5               |        | 1:53 |
| \_  Day 6               |        | 1:09 |
#+END:


* Process

An evolving checklist of "best practices" emerging as I work through the
problems.

1. Add [[* Template][new entry]] for notes for the day and clock in
2. Set up test harness in  [[./test]]
   - Copy test input into =./test/dayN.t/test=
   - Copy puzzle input into =./test/dayN.t/input=
   - Set up integration tests in =./test/dayN.t/run.t=
3. Set up solution scaffolding:
   - Add module =DayN.ml= to [[./bin]]
   - Add skeleton to module:
       #+begin_src ocaml
       open Containers

       module type Domain = sig
         (* TODO Specification of domain *)
       end

       module Solver (D : Domain) = struct
         let solve : string Array.t -> string Seq.t -> int =
           fun params lines ->
           (* TODO Solution to puzzle *)
             (??)
       end

       module D : Domain = struct
         (* TODO Implementation of domain *)
       end

       (* Instantiate the solver *)
       include Solver (D)
       #+end_src
     - Register the module in the [[./bin/main.ml::5][solvers]]
4. Extract semi-formal specification from puzzle description (as bullet points)
5. Specify the =Domain= interface
6. Implement preliminary =Solver= algorithm (usually calling for adjustments to =Domain=)
7. Implement =Domain= in =D=

* Tracking and Reflection
** Days 1 to 5

Was not taking notes or recording times.

Main takeaways:

- Avoid refactoring foo: some refactoring to reuse parts can be help accelerate,
  but it's also an easy place to procrastinate and avoid actually tackling the
  problems.
- Specify problems at type level *before* implementing. Helps prevent losing
  focus, since you can focus just on the high level representation, then get the
  type checker to give an interactive "checklist" of values you need to
  implement.
- If the aim is time-efficient implementations, don't rely on OCaml's till
  impoverished stdlib. I ended up having to implement too many basic utility
  functions. From Day 5 on, I'm helping myself to [[https://github.com/c-cube/ocaml-containers][Containers]].
- Bullet-point out the key details of the specification before starting to code
  up anything. Most of the mistakes that have slowed me down have come from
  making minor mistakes at the value-level during specification.


** DONE Day 5
:LOGBOOK:
CLOCK: [2021-12-05 Sun 12:00]--[2021-12-05 Sun 12:13] =>  0:13
CLOCK: [2021-12-05 Sun 09:28]--[2021-12-05 Sun 09:49] =>  0:21
CLOCK: [2021-12-05 Sun 08:04]--[2021-12-05 Sun 09:23] =>  1:19
:END:

*** Implementation

[[./bin/day5.ml][Solution]]

**** Errors
- Was initializing map locations incorrectly initially, setting them to 0 at the
  first marked point, rather to 1.
- Misread the specification: it called for returning the *number of points with
  2 or more overlapping vents*, but I was returning *the sum of all spaces with
  2 or more overlapping vents*.

Both of these errors are results of not carefully attending to *specific value
ranges* detailed by the specification.
**** To improve

- Bullet-point specification in english before writing formalizing specification
  in types.

** STRT Day 6
:LOGBOOK:
CLOCK: [2021-12-06 Mon 02:26]--[2021-12-06 Mon 03:35] =>  1:09
:END:

*** Specification

- Given :: A list of numbers representing ages of lanternfish
- Produce :: The number of fish expected at 80 days
- Domain ::
  - Each mature lanternfish creates a new fish after 7 days
  - Newly born lanternfish take +2 days to mature

- Representation ::
  - Represent each lantern fish as a single number, which acts as a counter
  - Represent a day passing as an iteration that reduces all counters
  - 1 new counter is created when any counter decreases from 0
  - A new counter start at 8 (2 days to mature + 7 days to produce)
  - After a counter reaches 0, it resets to 6

*** Implementation
[[./bin/day6.ml][Solution]]

- We only have 9 counter states to track: 0 to 8.
- To compute the number of new counters spawned, we need only track how many of
  each counter are in each state.
- So we can represent the state space as an =int Array.t= of length 9, where the
  =j_th= int represents the number of counters in that state.
- Proof that this alternative representation is equivalent to the one
  specified is given by the pair of functions

    - =array_to_counters : int Array.t -> int list=
    - =counters_to_array : int list -> int Array.t=

  defining an isomorphic mapping between the compressed representation and the
  list of counters.

*** Reflection

Today went very smoothly. Whether it was because today's puzzle was easier, or
admitted an elegant solution more easily than previous days, whether I just got
lucky striking on the right representation, or whether my process improvements
may be helping, I feel that it was pretty nearly ideal.

**** Errors
Two small errors in counter increment logic.

- I placed the updates adding the new counters and the reset counters in the
  same loop used to shift the counters to the left.
- I had an off by one error, setting the expired counters to index 5 instead of
  6.

**** To improve
- Write implementation ideas in plaint text first.
- *Keep the domain abstract*. This gives much more flexibility in improving the
  representation, which you'll likely want to do, since working the problem will
  bring more insight into the structures you can draw upon.
- [[https://www.youtube.com/playlist?list=PLqgbyDNJ3NvVBYzC5CJ_9sjcnx2pueo4h]["first thought, best thought"]] is usually not the case, so give the initial
  representation and strategy a second thought.
- Writing out update algorithm in bullet points prior to coding may have helped
  avoid the two errors I encountered.


* Template
** Day N
*** Specification
*** Implementation
[[./bin/dayN.ml][Solution]]
*** Reflection
**** Errors
**** To improve
